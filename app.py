# FILE: app.py
import os
import json
import hashlib
import shutil
from datetime import datetime
import secrets
import logging
from logging.handlers import TimedRotatingFileHandler
from flask import Flask, request, render_template, jsonify, session, redirect, url_for
from waitress import serve
import faiss
import numpy as np
from sentence_transformers import SentenceTransformer
from llm_client import call_llm
import subprocess # Th√™m import n√†y
import platform   # Th√™m import n√†y
import time       # Th√™m import n√†y

# ===================== C·∫•u h√¨nh Logging =====================
LOG_DIR = "logs"
os.makedirs(LOG_DIR, exist_ok=True)
log_file_app = os.path.join(LOG_DIR, f"app_{datetime.now().strftime('%Y-%m-%d')}.log")
handler = TimedRotatingFileHandler(log_file_app, when="midnight", interval=1, backupCount=7)
formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s [in %(pathname)s:%(lineno)d]')
handler.setFormatter(formatter)
logging.basicConfig(handlers=[handler], level=logging.INFO)

# ===================== KH·ªûI T·∫†O FLASK APP =====================
app = Flask(__name__, template_folder='webchat/templates', static_folder='webchat/static')
app.secret_key = secrets.token_hex(16)
logging.getLogger('werkzeug').setLevel(logging.ERROR)
logging.getLogger('waitress').disabled = True

# ===================== CONFIG & GLOBAL STATE =====================
BASE_DIR = os.path.dirname(os.path.abspath(__file__))
DATA_DIR = os.path.join(BASE_DIR, "data")
USERS_FILE = os.path.join(DATA_DIR, "users", "users.json")
HISTORY_BASE_DIR = os.path.join(DATA_DIR, "chat_histories")
RAG_PENDING_DIR = os.path.join(DATA_DIR, "rag_pending")
VECTOR_STORE_DIR = os.path.join(DATA_DIR, "vector_store")
FAISS_INDEX_PATH = os.path.join(VECTOR_STORE_DIR, "faiss.index")
CHUNK_MAP_PATH = os.path.join(VECTOR_STORE_DIR, "chunk_map.json")

embed_model, faiss_index, chunk_map = None, None, {}
TOKEN_PER_CHAR = 4
CONTEXT_LIMIT = 7000 # Ng∆∞·ª°ng an to√†n cho 8k context

# ===================== C√ÅC H√ÄM H·ªñ TR·ª¢ H·ªÜ TH·ªêNG =====================
def kill_process_on_port(port):
    """
    Ki·ªÉm tra v√† d·ª´ng ti·∫øn tr√¨nh ƒëang s·ª≠ d·ª•ng m·ªôt c·ªïng c·ª• th·ªÉ.
    H·ªó tr·ª£ c·∫£ Windows v√† Linux/macOS.
    """
    logging.info(f"Ki·ªÉm tra v√† d·ª´ng ti·∫øn tr√¨nh c≈© tr√™n port {port}...")
    try:
        if platform.system() == "Windows":
            command = f"netstat -aon | findstr :{port}"
            output = subprocess.check_output(command, shell=True, text=True, stderr=subprocess.DEVNULL)
            if "LISTENING" in output:
                # L·∫•y PID t·ª´ d√≤ng output
                pid = output.strip().split()[-1]
                subprocess.run(f"taskkill /F /PID {pid}", shell=True, check=True)
                logging.info(f"‚úÖ ƒê√£ d·ª´ng ti·∫øn tr√¨nh PID {pid} tr√™n port {port}.")
                print(f"‚úÖ ƒê√£ d·ª´ng ti·∫øn tr√¨nh PID {pid} tr√™n port {port}.")
        else: # Linux & macOS
            command = f"lsof -t -i:{port}"
            pids_output = subprocess.check_output(command, shell=True, text=True, stderr=subprocess.DEVNULL).strip()
            pids = pids_output.split('\n') if pids_output else []
            for pid in filter(None, pids):
                subprocess.run(f"kill -9 {pid}", shell=True, check=True)
                logging.info(f"‚úÖ ƒê√£ d·ª´ng ti·∫øn tr√¨nh PID {pid} tr√™n port {port}.")
                print(f"‚úÖ ƒê√£ d·ª´ng ti·∫øn tr√¨nh PID {pid} tr√™n port {port}.")
        if not pids and platform.system() != "Windows" and "LISTENING" not in output: # Check for no active processes found
            logging.info(f"‚úÖ Port {port} ƒëang r·∫£nh.")
            print(f"‚úÖ Port {port} ƒëang r·∫£nh.")

    except subprocess.CalledProcessError as e:
        # L·ªánh kh√¥ng th√†nh c√¥ng (c√≥ th·ªÉ do kh√¥ng t√¨m th·∫•y ti·∫øn tr√¨nh)
        logging.info(f"‚úÖ Port {port} ƒëang r·∫£nh ho·∫∑c kh√¥ng t√¨m th·∫•y ti·∫øn tr√¨nh c·∫ßn d·ª´ng.")
        print(f"‚úÖ Port {port} ƒëang r·∫£nh ho·∫∑c kh√¥ng t√¨m th·∫•y ti·∫øn tr√¨nh c·∫ßn d·ª´ng.")
    except FileNotFoundError:
        logging.warning(f"L·ªánh 'netstat' (Windows) ho·∫∑c 'lsof' (Linux/macOS) kh√¥ng t√¨m th·∫•y. Kh√¥ng th·ªÉ ki·ªÉm tra port {port}.")
        print(f"üü° L·ªánh 'netstat' ho·∫∑c 'lsof' kh√¥ng t√¨m th·∫•y. Kh√¥ng th·ªÉ ki·ªÉm tra port {port}.")
    except Exception as e:
        logging.error(f"‚ùå L·ªói khi d·ªçn d·∫πp port {port}: {e}")
        print(f"‚ùå L·ªói khi d·ªçn d·∫πp port {port}: {e}")

# ===================== C√ÅC H√ÄM LOGIC C·ªêT L√ïI =====================
def sanitize_string(text: str) -> str: return text.encode('utf-8', 'replace').decode('utf-8')
def hash_password(password: str) -> str: return hashlib.sha256(password.encode()).hexdigest()
def count_tokens_simple(messages: list) -> int: return sum(len(m.get("content", "")) // TOKEN_PER_CHAR for m in messages)

def load_vector_engine():
    global embed_model, faiss_index, chunk_map
    logging.info("ƒêang t·∫£i SentenceTransformer model...")
    try:
        # Kh·ªüi t·∫°o m√¥ h√¨nh ch·ªâ m·ªôt l·∫ßn
        embed_model = SentenceTransformer('keepitreal/vietnamese-sbert')
        logging.info("ƒê√£ t·∫£i SentenceTransformer model.")

        if os.path.exists(FAISS_INDEX_PATH) and os.path.exists(CHUNK_MAP_PATH):
            logging.info("ƒêang t·∫£i FAISS index v√† chunk map...")
            faiss_index = faiss.read_index(FAISS_INDEX_PATH)
            with open(CHUNK_MAP_PATH, "r", encoding="utf-8") as f:
                chunk_map = json.load(f)
            logging.info("ƒê√£ t·∫£i FAISS index v√† chunk map.")
        else:
            logging.warning("FAISS index ho·∫∑c chunk map kh√¥ng t√¨m th·∫•y. RAG s·∫Ω kh√¥ng ho·∫°t ƒë·ªông.")
            faiss_index = None
            chunk_map = {}
    except Exception as e:
        logging.error(f"L·ªói khi t·∫£i vector engine: {e}")
        embed_model = None
        faiss_index = None
        chunk_map = {}

def retrieve_context(query, top_k=3):
    if not embed_model or not faiss_index or not chunk_map:
        logging.warning("Vector engine ch∆∞a ƒë∆∞·ª£c t·∫£i, b·ªè qua RAG.")
        return "Kh√¥ng c√≥ ng·ªØ c·∫£nh RAG."

    try:
        query_vector = embed_model.encode([query])
        D, I = faiss_index.search(np.array(query_vector).astype('float32'), top_k)
        context = [chunk_map[str(idx)] for idx in I[0] if str(idx) in chunk_map]
        logging.info(f"ƒê√£ truy xu·∫•t ng·ªØ c·∫£nh RAG: {context}")
        return "\n".join(context)
    except Exception as e:
        logging.error(f"L·ªói khi truy xu·∫•t ng·ªØ c·∫£nh RAG: {e}")
        return "L·ªói khi truy xu·∫•t ng·ªØ c·∫£nh RAG."

def get_ai_response(user_input, chat_history):
    user_input = sanitize_string(user_input)
    rag_context = retrieve_context(user_input)
    system_prompt = f"B·∫°n l√† m·ªôt tr·ª£ l√Ω AI k·ªπ thu·∫≠t c√≥ t√™n l√† AI Agent. B·∫°n ph·∫£i tr·∫£ l·ªùi c√°c c√¢u h·ªèi d·ª±a tr√™n c√°c t√†i li·ªáu ƒë√£ ƒë∆∞·ª£c cung c·∫•p (n·∫øu c√≥) v√† kh√¥ng ƒë∆∞·ª£c b·ªãa ƒë·∫∑t th√¥ng tin. N·∫øu b·∫°n kh√¥ng bi·∫øt, h√£y n√≥i r·∫±ng b·∫°n kh√¥ng bi·∫øt. Lu√¥n gi·ªØ c√¢u tr·∫£ l·ªùi ng·∫Øn g·ªçn v√† ƒëi th·∫≥ng v√†o v·∫•n ƒë·ªÅ.\n\n### Ng·ªØ c·∫£nh t·ª´ RAG:\n{rag_context}"

    # === LOGIC C·∫ÆT GI·∫¢M TOKEN ===
    temp_history = list(chat_history) # T·∫°o b·∫£n sao ƒë·ªÉ x·ª≠ l√Ω
    messages = [{"role": "system", "content": system_prompt}] + temp_history + [{"role": "user", "content": user_input}]

    current_tokens = count_tokens_simple(messages)

    while current_tokens > CONTEXT_LIMIT and len(temp_history) > 1:
        # X√≥a c·∫∑p tin nh·∫Øn c≈© nh·∫•t (user v√† assistant)
        temp_history.pop(0)
        temp_history.pop(0)
        messages = [{"role": "system", "content": system_prompt}] + temp_history + [{"role": "user", "content": user_input}]
        current_tokens = count_tokens_simple(messages)
        logging.info(f"Context trimmed. New token count: {current_tokens}")

    # C·∫≠p nh·∫≠t l·∫°i chat_history trong session sau khi ƒë√£ c·∫Øt gi·∫£m
    session['chat_history'] = temp_history

    reply = call_llm(messages)
    clean_reply = sanitize_string(reply)

    # T√≠nh to√°n l·∫°i token count sau khi c√≥ ph·∫£n h·ªìi ƒë·ªÉ ch√≠nh x√°c h∆°n
    final_messages = messages + [{"role": "assistant", "content": clean_reply}]
    token_count = count_tokens_simple(final_messages)

    return clean_reply, token_count

# ===================== FLASK ROUTES (Ph·∫ßn Web) =====================
@app.route('/login', methods=['GET', 'POST'])
def login():
    if 'username' in session:
        return redirect(url_for('chat_ui'))
    if request.method == 'POST':
        username = request.form['username']
        password = request.form['password']
        try:
            with open(USERS_FILE, "r") as f:
                users = json.load(f)
            password_hash = hash_password(password)
            user_data = next((u for u in users if u['username'] == username and u['password_hash'] == password_hash), None)
            if user_data:
                session['username'] = username
                session['active_session_id'] = None # Phi√™n m·ªõi, ch∆∞a c√≥ ID
                session['chat_history'] = []
                logging.info(f"User '{username}' logged in.")
                return redirect(url_for('chat_ui'))
            else:
                return render_template('login.html', error="Sai t√™n ƒëƒÉng nh·∫≠p ho·∫∑c m·∫≠t kh·∫©u")
        except FileNotFoundError:
            return render_template('login.html', error="L·ªói h·ªá th·ªëng: Kh√¥ng t√¨m th·∫•y file ng∆∞·ªùi d√πng.")
        except Exception as e:
            logging.error(f"L·ªói ƒëƒÉng nh·∫≠p: {e}")
            return render_template('login.html', error="L·ªói h·ªá th·ªëng.")
    return render_template('login.html')

@app.route('/')
def chat_ui():
    if 'username' not in session: return redirect(url_for('login'))
    return render_template('chat.html',
                           username=session['username'],
                           session_id=session.get('active_session_id', 'Phi√™n M·ªõi'))

@app.route('/ask', methods=['POST'])
def ask():
    if 'username' not in session: return jsonify({"error": "Ch∆∞a ƒëƒÉng nh·∫≠p"}), 401
    user_message = request.json['message']
    
    # L·∫•y l·ªãch s·ª≠ chat hi·ªán t·∫°i t·ª´ session, n·∫øu kh√¥ng c√≥ th√¨ l√† list r·ªóng
    chat_history = session.get('chat_history', [])

    reply_content, token_count = get_ai_response(user_message, chat_history)

    # C·∫≠p nh·∫≠t l·ªãch s·ª≠ chat trong session
    chat_history.append({"role": "user", "content": user_message})
    chat_history.append({"role": "assistant", "content": reply_content})
    session['chat_history'] = chat_history

    logging.info(f"User '{session['username']}' asked: '{user_message}' | AI replied: '{reply_content[:50]}...' (Tokens: {token_count})")
    return jsonify({"reply": reply_content, "token_count": token_count})

@app.route('/logout')
def logout():
    username = session.pop('username', None)
    if username:
        logging.info(f"User '{username}' logged out.")
    session.clear()
    return redirect(url_for('login'))

@app.route('/new_session', methods=['POST'])
def new_session_api():
    if 'username' not in session: return jsonify({"error": "Ch∆∞a ƒëƒÉng nh·∫≠p"}), 401
    session['chat_history'] = []
    session['active_session_id'] = None # Reset ID c·ªßa phi√™n ƒëang ho·∫°t ƒë·ªông
    logging.info(f"User '{session['username']}' started a new session.")
    return jsonify({"status": "success"})

@app.route('/save_session', methods=['POST'])
def save_session_api():
    if 'username' not in session: return jsonify({"error": "Ch∆∞a ƒëƒÉng nh·∫≠p"}), 401

    username = session['username']
    chat_history = session.get('chat_history', [])
    active_session_id = session.get('active_session_id')
    user_history_path = os.path.join(HISTORY_BASE_DIR, username)
    os.makedirs(user_history_path, exist_ok=True)

    session_name = request.json.get('session_name', '').strip()
    sanitized_name = "".join(c for c in session_name if c.isalnum() or c in (' ', '_')).rstrip()

    filename_base = None
    if active_session_id and active_session_id != 'Phi√™n M·ªõi':
        # N·∫øu c√≥ active_session_id v√† kh√¥ng ph·∫£i "Phi√™n M·ªõi", s·ª≠ d·ª•ng l·∫°i n√≥
        filename_base = active_session_id
        message = f"ƒê√£ c·∫≠p nh·∫≠t phi√™n: {filename_base}"
    elif sanitized_name:
        # N·∫øu kh√¥ng c√≥ active_session_id nh∆∞ng c√≥ t√™n m·ªõi ƒë∆∞·ª£c cung c·∫•p
        filename_base = sanitized_name
        message = f"ƒê√£ l∆∞u phi√™n m·ªõi: {filename_base}"
    else:
        # N·∫øu kh√¥ng c√≥ c·∫£ hai, t·∫°o t√™n t·ª± ƒë·ªông
        filename_base = datetime.now().strftime('%Y%m%d_%H%M%S')
        message = f"ƒê√£ l∆∞u phi√™n m·ªõi t·ª± ƒë·ªông: {filename_base}"
    
    filename = f"{filename_base}.json"
    session['active_session_id'] = filename_base # C·∫≠p nh·∫≠t ID phi√™n ƒëang ho·∫°t ƒë·ªông

    filepath = os.path.join(user_history_path, filename)
    with open(filepath, "w", encoding="utf-8") as f: json.dump(chat_history, f, ensure_ascii=False, indent=2)
    logging.info(f"User '{username}' saved session: {filename}")
    return jsonify({"status": "success", "message": message, "new_session_id": session.get('active_session_id')})


@app.route('/history/list', methods=['GET'])
def list_history_api():
    if 'username' not in session: return jsonify({"error": "Ch∆∞a ƒëƒÉng nh·∫≠p"}), 401
    username = session['username']
    user_history_path = os.path.join(HISTORY_BASE_DIR, username)
    
    sessions = []
    if os.path.exists(user_history_path):
        for f in os.listdir(user_history_path):
            if f.endswith(".json"):
                sessions.append(os.path.splitext(f)[0]) # L·∫•y t√™n file kh√¥ng c√≥ ƒëu√¥i .json
        sessions.sort(reverse=True) # S·∫Øp x·∫øp ƒë·ªÉ c√°c phi√™n m·ªõi nh·∫•t l√™n ƒë·∫ßu
    
    logging.info(f"User '{username}' requested history list. Found {len(sessions)} sessions.")
    return jsonify(sessions)

@app.route('/history/load', methods=['POST'])
def load_history_api():
    if 'username' not in session: return jsonify({"error": "Ch∆∞a ƒëƒÉng nh·∫≠p"}), 401
    session_id = request.json['session_id']
    username = session['username']
    filepath = os.path.join(HISTORY_BASE_DIR, username, f"{session_id}.json")
    if os.path.exists(filepath):
        with open(filepath, "r", encoding="utf-8") as f: chat_history = json.load(f)
        session['chat_history'] = chat_history
        session['active_session_id'] = session_id # ƒê·∫∑t phi√™n n√†y l√† phi√™n ƒëang ho·∫°t ƒë·ªông
        logging.info(f"User '{username}' loaded session: {session_id}")
        return jsonify({"status": "success", "history": chat_history, "session_id": session_id})
    logging.warning(f"User '{username}' attempted to load non-existent session: {session_id}")
    return jsonify({"error": "Kh√¥ng t√¨m th·∫•y phi√™n chat"}), 404

@app.route('/history/delete', methods=['POST'])
def delete_history_api():
    if 'username' not in session: return jsonify({"error": "Ch∆∞a ƒëƒÉng nh·∫≠p"}), 401
    session_id = request.json['session_id']
    username = session['username']
    filepath = os.path.join(HISTORY_BASE_DIR, username, f"{session_id}.json")
    if os.path.exists(filepath):
        os.remove(filepath)
        logging.info(f"User '{username}' deleted session: {session_id}")
        return jsonify({"status": "success"})
    logging.warning(f"User '{username}' attempted to delete non-existent session: {session_id}")
    return jsonify({"error": "Kh√¥ng t√¨m th·∫•y phi√™n chat"}), 404

@app.route('/history/rename', methods=['POST'])
def rename_history_api():
    if 'username' not in session: return jsonify({"error": "Ch∆∞a ƒëƒÉng nh·∫≠p"}), 401
    old_id = request.json['old_id']
    new_name = request.json['new_name'].strip()
    username = session['username']
    user_path = os.path.join(HISTORY_BASE_DIR, username)

    sanitized_new_name = "".join(c for c in new_name if c.isalnum() or c in (' ', '_')).rstrip()
    if not sanitized_new_name:
        return jsonify({"error": "T√™n m·ªõi kh√¥ng h·ª£p l·ªá."}), 400

    old_filepath = os.path.join(user_path, f"{old_id}.json")
    new_filepath = os.path.join(user_path, f"{sanitized_new_name}.json")

    if os.path.exists(new_filepath):
        return jsonify({"status": "error", "error": "T√™n m·ªõi ƒë√£ t·ªìn t·∫°i."}), 409
    if os.path.exists(old_filepath):
        os.rename(old_filepath, new_filepath)
        # N·∫øu phi√™n hi·ªán t·∫°i ƒëang ho·∫°t ƒë·ªông b·ªã ƒë·ªïi t√™n, c·∫≠p nh·∫≠t active_session_id
        if session.get('active_session_id') == old_id:
            session['active_session_id'] = sanitized_new_name
        logging.info(f"User '{username}' renamed '{old_id}' to '{sanitized_new_name}'")
        return jsonify({"status": "success", "message": f"ƒê√£ ƒë·ªïi t√™n phi√™n t·ª´ '{old_id}' th√†nh '{sanitized_new_name}'."})
    logging.warning(f"User '{username}' attempted to rename non-existent session: {old_id}")
    return jsonify({"status": "error", "error": "Kh√¥ng t√¨m th·∫•y phi√™n chat"}), 404

@app.route('/rag_save', methods=['POST'])
def rag_save_api():
    if 'username' not in session: return jsonify({"error": "Ch∆∞a ƒëƒÉng nh·∫≠p"}), 401
    username = session['username']
    chat_history = session.get('chat_history', [])

    if not chat_history:
        return jsonify({"status": "error", "message": "Kh√¥ng c√≥ l·ªãch s·ª≠ chat ƒë·ªÉ g·ª≠i."}), 400

    rag_pending_user_dir = os.path.join(RAG_PENDING_DIR, username)
    os.makedirs(rag_pending_user_dir, exist_ok=True)

    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    filename = f"rag_feedback_{timestamp}.json"
    filepath = os.path.join(rag_pending_user_dir, filename)

    try:
        with open(filepath, "w", encoding="utf-8") as f:
            json.dump(chat_history, f, ensure_ascii=False, indent=2)
        logging.info(f"User '{username}' submitted chat for RAG feedback: {filename}")
        return jsonify({"status": "success", "message": "Phi√™n chat ƒë√£ ƒë∆∞·ª£c g·ª≠i th√†nh c√¥ng ƒë·ªÉ g√≥p √Ω RAG. C·∫£m ∆°n ph·∫£n h·ªìi c·ªßa b·∫°n!"})
    except Exception as e:
        logging.error(f"L·ªói khi l∆∞u feedback RAG: {e}")
        return jsonify({"status": "error", "message": f"ƒê√£ x·∫£y ra l·ªói khi g·ª≠i g√≥p √Ω RAG: {e}"}), 500

# ===================== KH·ªûI ƒê·ªòNG ·ª®NG D·ª§NG =====================
if __name__ == '__main__':
    APP_PORT = 5000
    kill_process_on_port(APP_PORT) # G·ªçi h√†m ƒë·ªÉ kill port tr∆∞·ªõc khi kh·ªüi ƒë·ªông
    time.sleep(1) # ƒê·ª£i m·ªôt ch√∫t ƒë·ªÉ ti·∫øn tr√¨nh c≈© ƒë∆∞·ª£c gi·∫£i ph√≥ng ho√†n to√†n
    load_vector_engine()
    print(f"üöÄ B·∫Øt ƒë·∫ßu kh·ªüi ƒë·ªông AI Agent tr√™n http://0.0.0.0:{APP_PORT}")
    serve(app, host='0.0.0.0', port=APP_PORT, threads=8)
